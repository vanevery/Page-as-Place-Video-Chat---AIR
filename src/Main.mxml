<?xml version="1.0" encoding="utf-8"?>
<s:WindowedApplication xmlns:fx="http://ns.adobe.com/mxml/2009" 
					   xmlns:s="library://ns.adobe.com/flex/spark" 
					   xmlns:mx="library://ns.adobe.com/flex/mx"
					   applicationComplete="init()" viewSourceURL="srcview/index.html">
	
	<fx:Style> 
		@namespace s "library://ns.adobe.com/flex/spark"; 
		s|WindowedApplication 
		{ 
			skinClass:ClassReference("spark.skins.spark.SparkChromeWindowedApplicationSkin"); 
			background-color:#999999; 
			background-alpha:"0.7"; 
		}          
	</fx:Style>
	
	<fx:Declarations>
		<!-- Place non-visual elements (e.g., services, value objects) here -->
	</fx:Declarations>
	
	<fx:Script>
		<![CDATA[
			import flash.filters.ColorMatrixFilter;
			import flash.filters.ConvolutionFilter;
			import flash.html.*;
			
			import mx.collections.ArrayCollection;
			
			import spark.events.IndexChangeEvent;
			
			public static const FMIS_APP:String = "rtmp://itp-flash.es.its.nyu.edu/sve204/mictest";
			public static const WEB_URL:String = "http://itp.nyu.edu/";
			
			private var htmlLoader:HTMLLoader;
			
			private var netConnection:NetConnection;
			
			private var localNetStream:NetStream;
			
			private var camera:Camera;
			private var microphone:Microphone;
			private var video:Video;
			
			private var localStreamName:String = "stream0";
			private var remoteStreamName:String = "stream1";
			
			private var remoteNetStream:NetStream;
			private var remoteVideo:Video;
			
			// SHOULD BE CONSTANTS
			private var videoWidth:Number = 80;
			private var videoHeight:Number = 60;
						
			// Responder (for communicating messages with FMS) specifically, which stream am I?
			private var selectStreamResponder:Responder;
			
			private var sharedObject:SharedObject;
						
			private var bmp:Bitmap;
			private var bmpd:BitmapData;
			private var pbmpd:BitmapData;  // Previous Frame
			private var frameTimer:Timer;
			
			private var rbmp:Bitmap;
			private var rbmpd:BitmapData;
			private var rpbmpd:BitmapData;
			private var rframeTimer:Timer;
						
			public static const TIMER_INTERVAL:Number = 100;
			
			private var availableCameras:Array;
						
			// Runs at launch
			private function init():void
			{
				trace("init");
				
				availableCameras = Camera.names;
				trace(availableCameras);
				availableCamerasComboBox.dataProvider = new ArrayCollection(availableCameras);

				initHTMLViewer();			
			}
			
			private function initNetConnection():void 
			{
				if (netConnection != null) {
					netConnection.close();
					netConnection = null;
				}
				
				netConnection = new NetConnection();
				netConnection.client = new Object();
				netConnection.client.onBWDone = onBWDone;
				netConnection.client.onMetaData = onMetaData;
				netConnection.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
				
				netConnection.connect(FMIS_APP);				
			}
			
			private function initHTMLViewer():void 
			{
				htmlLoader = htmlComponent.htmlLoader;
				
				htmlLoader.width = stage.width;
				htmlLoader.height = stage.height;
				
				var urlRequest:URLRequest = new URLRequest(WEB_URL);
				
				var theHTMLHost:TheHTMLHost = new TheHTMLHost();
				htmlLoader.htmlHost = theHTMLHost;
				theHTMLHost.eventDispatcher.addEventListener(HTMLHostEvent.UPDATETITLE_EVENT,newTitle);
				theHTMLHost.eventDispatcher.addEventListener(HTMLHostEvent.UPDATELOCATION_EVENT,newLocation);
				
				htmlLoader.load(urlRequest);
			}
			
			private function onBWDone():void 
			{
				debug("onBWDone");
			}
			
			private function onCuePoint(infoObject:Object):void 
			{
				debug("cuePoint");
			}
			
			private function onMetaData(infoObject:Object):void 
			{
				debug("metaData");
			}
									
			private function netStatusHandler(event:NetStatusEvent):void 
			{
				debug(event.info.code);
				
				switch (event.info.code) 
				{
					case "NetConnection.Connect.Success":
						
						debug("Connected");
						debug("Asking for stream name");
						
						selectStreamResponder = new Responder(selectStreamResponse);
						netConnection.call("streamSelect",selectStreamResponder);
						
						// Set up the shared object for sending recieving mouse positions
						// We'll call it SimpleSO, pass in the app url and not make it persistent
						sharedObject = SharedObject.getRemote("SimpleSO",netConnection.uri,false);
						
						// Add a listener for when shared object is changed
						//sharedObject.addEventListener(SyncEvent.SYNC,syncEventCallBack); 
						
						// Call methods on this
						sharedObject.client = this;
						
						// Connect the shared object to our netConnection
						sharedObject.connect(netConnection);						
						
						break;
					
					case "NetConnection.Connect.Closed":
						debug("Connection Closed");
						rframeTimer.stop();
						// Why is this happening?
						break;
					
					case "NetStream.Play.Start":
						
						if (event.target == remoteNetStream) {
							debug("Playing");
							
							// Remote Video Manipulation
							rbmpd = new BitmapData(videoWidth,videoHeight,true,0x00ffffff);
							rpbmpd = new BitmapData(videoWidth,videoHeight,true,0x00ffffff);
							rbmp = new Bitmap(rbmpd);
							
							rbmp.x = videoWidth + 10;
							rbmp.y = 0;
							rbmp.width = 160;
							rbmp.height = 120;
							stage.addChild(rbmp);
							
							// Create timer
							rframeTimer = new Timer(TIMER_INTERVAL,0);
							rframeTimer.addEventListener(TimerEvent.TIMER, rgrabFrame);	
							rframeTimer.start();				
						}
						
						break;
					
					case "NetConnection.Connect.Closed":
						
						if (event.target == remoteNetStream) {
							debug("Remote Connection Closed");
							rframeTimer.stop();
						} else if (event.target == localNetStream) {
							debug("Local Connection Closed");
						} else {
							debug("Something Else Closed");
						}
						
						break;
					
					default:
						
						debug("Not Handled");	
						break;
				}
			}			

			public function mousePostionChanged(streamName:String, x:Number, y:Number):void {
				//debug(streamName + ":" + x + "," + y);
				
				if (streamName == remoteStreamName) {
					rbmp.x = x;
					rbmp.y = y;					
				}
				
				adjustVolumes();
			}
			
			private function sendMousePosition(streamName:String, x:Number, y:Number):void {
				if (sharedObject != null) {
					sharedObject.send("mousePostionChanged",streamName,x,y);
				}
			}
			
			private function selectStreamResponse(streamNames:String):void
			{
				debug("Got stream names");
				
				var theStreamNames = streamNames.split(":");
				if (theStreamNames.length > 0)
				{ 	
					debug("I am : " + theStreamNames[0]);
					localStreamName = theStreamNames[0];
					startLocalStream();
					
					if (theStreamNames.length > 1)
					{
						debug("Remote is : " + theStreamNames[1]);
						remoteStreamName = theStreamNames[1];
						
						//DEBUGGING
						//remoteStreamName = localStreamName;
						//DEBUGGING
						
						startRemoteStream();
					}
				}
			}
						
			private function startLocalStream():void
			{
				debug("Starting Local Stream");
				
				// Create local netstream
				localNetStream = new NetStream(netConnection);
				
				// Add Handlers
				localNetStream.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
				
				// Get a local camera
				debug("Selected Camera: " + availableCamerasComboBox.selectedIndex);
				camera = Camera.getCamera(availableCamerasComboBox.selectedIndex as String);
								
				// Ask to be notified when user makes a choice regarding access
				camera.addEventListener(StatusEvent.STATUS, cameraStatus);
				
				// Set the mode of the camera component
				// width, height, fps
				camera.setMode(videoWidth,videoHeight,15);
				
				// Get the microphone component
				microphone = Microphone.getMicrophone();
				
				//microphone.gain = Number(10);
				debug("Gain: " + microphone.gain);
				
				//microphone.rate = Number();
				debug("Rate: " + microphone.rate);
				
				microphone.setUseEchoSuppression(true);
				debug("Echo: " + microphone.useEchoSuppression);	
				
				//microphone.setSilenceLevel();
				debug("Silence: " + microphone.silenceLevel);
				
				//microphone.useEchoSuppression
				//microphone.setLoopBack(true);
				//debug("Loopback: true");
				
				microphone.codec = "Speex";	
				debug("Speex");
				
				//microphone.encodeQuality = 
				debug("Quality: " + microphone.encodeQuality);
				
				// Attach the camera to the netstream object
				localNetStream.attachCamera(camera);
				debug("Attached Camera");
				
				// Attach the mic to the netstream object
				localNetStream.attachAudio(microphone);
				debug("Attached Microphone");
				
				// Create a video object
				video = new Video(videoWidth, videoHeight);
				debug("Created Video Object");	
				
				localVideoDisplay.addChild(video);
				debug("Added Video Object");
				
				// Attach the camera object to the video object
				video.attachCamera(camera);
				debug("Attached Camera to Video Object");
				
				// Publish the stream
				localNetStream.publish(localStreamName);
				debug("Publish Local Stream");
				
				//  The following is for video manipulation
				// Create the bitmapdata objects
				// Local
				bmpd = new BitmapData(videoWidth,videoHeight,true,0x00ffffff);
				pbmpd = new BitmapData(videoWidth,videoHeight,true,0x00ffffff);
				
				// Create the bitmap image
				bmp = new Bitmap(bmpd);
				
				// Add it to the stage
				bmp.x = 0;
				bmp.y = 0;
				bmp.width = 160;
				bmp.height = 120;

				stage.addChild(bmp);
				
				// Create timer
				frameTimer = new Timer(TIMER_INTERVAL,0);
				frameTimer.addEventListener(TimerEvent.TIMER, grabFrame);				
				frameTimer.start();				
				
				// Start transmitting mouse position
				stage.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoved);
			}
			
			private function startRemoteStream():void
			{
				debug("Start Remote Stream");
				
				remoteNetStream = new NetStream(netConnection);
				remoteNetStream.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
				
				// Add Handlers
				remoteNetStream.client = new Object();
				remoteNetStream.client.onCuePoint = onCuePoint;
				remoteNetStream.client.onMetaData = onMetaData;
				
				remoteNetStream.bufferTime = 0;
				remoteVideo = new Video(videoWidth, videoHeight);
				remoteVideo.attachNetStream(remoteNetStream);
				
				remoteNetStream.play(remoteStreamName);				
				remoteVideoDisplay.addChild(remoteVideo);
			}	

			private function cameraStatus(evt:StatusEvent):void {
				// Move down the z-index after permissions are given
				switch (evt.code) {
					case "Camera.Muted":
						debug("User denied access to camera.");
						break;
					case "Camera.Unmuted":
						debug("User allowed access to camera.");
						break;
				}
			}
			
			private function grabFrame(e:TimerEvent):void
			{
				//trace("timer");
				
				// Save the frame to the bitmapdata object
				bmpd.draw(video);
				
				var findEdges:ConvolutionFilter = new ConvolutionFilter(3, 3, [-1,0,1,-1,0,1,-1,0,1]);
				bmpd.applyFilter(bmpd,bmpd.rect,new Point(0,0),findEdges);

				if (pbmpd == null) {
					pbmpd.draw(bmpd);
				}
				
				// Combo with Edges
				// Cursor - Near other person - more resolution/color 
				// Sound - Volume as well
				for (var row:int=0; row<bmpd.height; row++) { //for each row
					for(var col:int=0; col<bmpd.width; col++) { //for each column
						//get the color of this pixels
						var pix:uint = bmpd.getPixel(col,row);
						var ppix:uint = pbmpd.getPixel(col,row);
						
						var red:int = pix >> 16;
						var pred:int = ppix >> 16;
						
						var green:int = pix >> 8 & 0xff;
						var pgreen:int = ppix >> 8 & 0xff;
						
						var blue:int = pix & 0xff;
						var pblue:int = ppix & 0xff;
						
						if (Math.abs(red - pred) + Math.abs(green - pgreen) + Math.abs(blue - pblue) > 50)
						{
							bmpd.setPixel(col,row,pix);
						}
						else 
						{
							bmpd.setPixel32(col,row,0x00FFFFFF);
						}
					}
				}
				
				pbmpd.draw(bmpd);
				
			}
			
			private function rgrabFrame(e:TimerEvent):void
			{
				//trace("timer");
				
				// Save the frame to the bitmapdata object
				//if (remoteVideo != null) {
					
					rbmpd.draw(remoteVideo);
					
					var findEdges:ConvolutionFilter = new ConvolutionFilter(3, 3, [-1,0,1,-1,0,1,-1,0,1]);
					rbmpd.applyFilter(rbmpd,rbmpd.rect,new Point(0,0),findEdges);

					
					if (rpbmpd == null) {
						rpbmpd.draw(rbmpd);
					}
					
					for (var row:int=0; row<rbmpd.height; row++) { //for each row
						for(var col:int=0; col<rbmpd.width; col++) { //for each column
							//get the color of this pixels
							var pix:uint = rbmpd.getPixel(col,row);
							var ppix:uint = rpbmpd.getPixel32(col,row);
							
							var red:int = pix >> 16;
							var pred:int = ppix >> 16;
							
							var green:int = pix >> 8 & 0xff;
							var pgreen:int = ppix >> 8 & 0xff;
							
							var blue:int = pix & 0xff;
							var pblue:int = ppix & 0xff;
							
							if (Math.abs(red - pred) + Math.abs(green - pgreen) + Math.abs(blue - pblue) > 50)
							{
								rbmpd.setPixel(col,row,pix);
							}
							else 
							{
								rbmpd.setPixel32(col,row,0x00FFFFFF);
							}
							
						}
					}
					
					rpbmpd.draw(rbmpd);
					
					
				//}

			}				
			
			private function userNewUrl():void {
				var theNewUrl:String = userUrl.text;
				
				// Send to Browser
				newUrl(theNewUrl);
				
				// Send to other users
				sendNewUrl(theNewUrl);
			}
						
			private function sendNewUrl(theNewUrl:String):void {
				if (sharedObject != null) {
					sharedObject.send("newUrl",theNewUrl);
				}
				
				userUrl.text = theNewUrl;
			}
			
			public function newUrl(theNewUrl:String):void {
				debug("got new URL via shared object, sending to browser");

				var urlRequest:URLRequest = new URLRequest(theNewUrl);				
				htmlLoader.load(urlRequest);			
				
				userUrl.text = theNewUrl;
			}
			
			private function newLocation(htmlHostEvent:HTMLHostEvent):void 
			{
				trace("Got New Location: " + htmlHostEvent.target.theUrl);
				
				sendNewUrl(htmlHostEvent.target.theUrl);
			}
			
			private function newTitle(htmlHostEvent:HTMLHostEvent):void
			{
				trace("Got New Title: " + htmlHostEvent.target.theTitle);
			}
			
			private function mouseMoved(e:MouseEvent):void 
			{
				//trace("mouse moved: " + e.localX + " " + e.localY);
				sendMousePosition(localStreamName, e.localX, e.localY);
				
				if (bmp != null) {
					bmp.x = e.localX;
					bmp.y = e.localY;
				}
				
				adjustVolumes();
			}
			
			private function debug(theText:String):void {
				trace(theText);
				textoutput.text += theText + "\n";
				textoutput.verticalScrollPosition = textoutput.maxVerticalScrollPosition;
			}
			
			private function adjustVolumes():void {
				var dist:Number = Math.sqrt(Math.pow(bmp.x - rbmp.x, 2) + Math.pow(bmp.y - rbmp.y, 2));
				var distFraction:Number = dist/Math.sqrt(Math.pow(stage.width, 2) + Math.pow(stage.height, 2));
				
				if (remoteNetStream != null) {
					var remoteVolumeTransform:SoundTransform = new SoundTransform();
					remoteVolumeTransform.volume = distFraction;
					remoteNetStream.soundTransform = remoteVolumeTransform;
					
					//debug("Set Sound to " + remoteVolumeTransform.volume);
				}
				
			}
			
		]]>
	</fx:Script>

	<mx:HTML id="htmlComponent"  horizontalCenter="0" verticalCenter="20" width="100%" height="100%"/>
	<mx:VideoDisplay id="remoteVideoDisplay" x="180" y="35" width="160" height="120" contentBackgroundAlpha="1.0" visible="false" />
	<mx:VideoDisplay id="localVideoDisplay" x="10" y="36" width="160" height="120" contentBackgroundAlpha="1.0" visible="false" />
	
	<mx:TextArea x="693" y="35" width="263" height="500" id="textoutput" text="nothing yet" visible="false" />
	<s:Button x="168" y="11" label="Connect" click="initNetConnection()" />
	<s:TextInput x="250" y="10" width="263" id="userUrl" />
	<s:Button x="539" y="11" label="Go" click="userNewUrl()" />
	<s:ComboBox id="availableCamerasComboBox" x="10" y="10" />

</s:WindowedApplication>
